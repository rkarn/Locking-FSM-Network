
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_Standard(

	//////////// CLOCK //////////
//	input 		          		CLOCK2_50,
//	input 		          		CLOCK3_50,
//	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	//input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		 reg    [9:0]		LEDR,

	//////////// Seg7 //////////
//	output		     [6:0]		HEX0,
//	output		     [6:0]		HEX1,
//	output		     [6:0]		HEX2,
//	output		     [6:0]		HEX3,
//	output		     [6:0]		HEX4,
//	output		     [6:0]		HEX5,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire RxD;
wire receive_done;
wire [7:0] receive_data;
//memory length calculation:
//Ks = 8 states * 3 bit per state = 24 bits. Steganography makes 8 keys value = 24* 8 = 192
//kf = ks = 192
//kt = 8 bit per xt. Steganography makes 8 keys value = 8* 8 = 64
// length = (192 + 192 +64)/8 = 56 words.
//total bits = 192+192+64=448
reg [7:0]key_storage_mem[55:0];
reg [6:0] keys_mem_address;
reg [447:0] key_storage_reg;  // key_storage_reg =[steganography(Ks) 192 bit, steganography(Kf) 192 bit, steganography(Kt) 64 bit] 
reg key_storage_valid;
reg [23:0] Ks; // permutation order [2, 5, 4, 1, 0, 3, 7, 6]
reg [23:0] Kf; // permutation order [3, 1, 6, 2, 4, 7, 0, 5]
reg [7:0] Kt;
reg ks_kf_kt_valid;
integer i;

wire reset, ip_stream_valid;
reg [7:0] input_xt_stream;
reg input_xt;
parameter FSM_state_N = 8;
reg [2:0] next_state;
reg [2:0] current_state;
reg [2:0] num_xt_sampled;
reg [2:0] FSM_output;

wire [2:0] psi_0 = Ks[14:12];
wire [2:0] psi_1 = Ks[11:9];
wire [2:0] psi_2 = Ks[2:0];
wire [2:0] psi_3 = Ks[17:15];
wire [2:0] psi_4 = Ks[8:6];
wire [2:0] psi_5 = Ks[5:3];
wire [2:0] psi_6 = Ks[23:21];
wire [2:0] psi_7 = Ks[20:18];
wire [2:0] pi_0 = Kf[20:18];
wire [2:0] pi_1 = Kf[5:3];
wire [2:0] pi_2 = Kf[11:9];
wire [2:0] pi_3 = Kf[2:0];
wire [2:0] pi_4 = Kf[14:12];
wire [2:0] pi_5 = Kf[23:21];
wire [2:0] pi_6 = Kf[8:6];
wire [2:0] pi_7 = Kf[17:15];


//=======================================================
//  Structural coding
//=======================================================

		  
								  
assign RxD = GPIO[0];  //UART receiver pin for FPGA
// GPIO[1];  //UART transmitter Pin for FPGA
assign reset = SW[0];
assign ip_stream_valid = SW[9];

always@(*)
begin
 if (keys_mem_address == 56)
		begin
			for(i=0; i<=55; i=i+1)
				begin
					key_storage_reg[i*3+:3] <= key_storage_mem[i];
				end
		key_storage_valid <= 1;
		end
	else
		begin
		key_storage_valid <= 0;	
		end
end

always @ (posedge CLOCK_50)
begin
	if (ip_stream_valid==1 && reset == 0)
		begin
			input_xt_stream <= SW[8:1]^Kt; //xoring the input to get the correct stream from locket xt. 
		end
		
	if (num_xt_sampled == 3'b111)
		begin
			FSM_output <= current_state;
			LEDR <= current_state;
		end

		
	if (reset == 1 && ip_stream_valid == 0)
		begin
			next_state <= 0;
			input_xt <= input_xt_stream[0];
			num_xt_sampled <= 0;
			current_state <= 0;
			keys_mem_address <=0;
			ks_kf_kt_valid <= 0;
		end
	else if (receive_done == 1 && keys_mem_address <= 55)
		begin
			key_storage_mem[keys_mem_address] <= receive_data;
			keys_mem_address <= keys_mem_address+1;
		end
	else if (keys_mem_address == 56 && key_storage_valid == 1)
		begin
			Ks <= key_storage_reg[351:328]; //[..,..,..,..,Ks,..,..,..] 
			Kf <= key_storage_reg[231:208]; //[..,Kf,..,..,..,..,..,..]
			Kt <= key_storage_reg[15:8];    //[..,..,..,..,..,..,Kt,..]
			ks_kf_kt_valid<= 1;
		end
	
	if (ks_kf_kt_valid == 1)
	begin
		case(next_state)
			psi_0: begin if(input_xt == 0) 
								begin next_state<= pi_0; end 
			             else 
								begin next_state<= pi_1; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1; 
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_0;
					 end
					 
			psi_1: begin if(input_xt == 0) 
								begin next_state<= pi_0; end 
			             else 
								begin next_state<= pi_2; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1;
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_1;
					 end					 
					 
			psi_2: begin if(input_xt == 0) 
								begin next_state<= pi_1; end 
			             else 
								begin next_state<= pi_3; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1;
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_2;
					 end
					 
			psi_3: begin if(input_xt == 0) 
								begin next_state<= pi_2; end 
			             else 
								begin next_state<= pi_4; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1;
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_3;
					 end
					 
			psi_4: begin if(input_xt == 0) 
								begin next_state<= pi_3; end 
			             else 
								begin next_state<= pi_5; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1;
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_4;
					 end
					 
			psi_5: begin if(input_xt == 0) 
								begin next_state<= pi_4; end 
			             else 
								begin next_state<= pi_6; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1;
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_5;
					 end
					 
			psi_6: begin if(input_xt == 0) 
								begin next_state<= pi_5; end 
			             else 
								begin next_state<= pi_7; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1;
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_6;
					 end
					 
			psi_7: begin if(input_xt == 0) 
								begin next_state<= pi_6; end 
			             else 
								begin next_state<= pi_7; end 
					 input_xt <= input_xt_stream[0];
					 input_xt_stream <= input_xt_stream >> 1;
					 num_xt_sampled <= num_xt_sampled+1;
					 current_state <= psi_7;
					 end
					 
		endcase
	end

end

uart_rx R1 (.i_Clock(CLOCK_50), .i_Rx_Serial(RxD), .o_Rx_DV(receive_done), .o_Rx_Byte(receive_data) );



endmodule


module uart_rx   #(parameter CLKS_PER_BIT = 53)
  (
   input        i_Clock,
   input        i_Rx_Serial,
   output       o_Rx_DV,
   output [7:0] o_Rx_Byte
   );
    
  parameter s_IDLE         = 3'b000;
  parameter s_RX_START_BIT = 3'b001;
  parameter s_RX_DATA_BITS = 3'b010;
  parameter s_RX_STOP_BIT  = 3'b011; 
  parameter s_CLEANUP      = 3'b100;
   
  reg           r_Rx_Data_R = 1'b1;
  reg           r_Rx_Data   = 1'b1;
   
  reg [7:0]     r_Clock_Count = 0;
  reg [2:0]     r_Bit_Index   = 0; //8 bits total
  reg [7:0]     r_Rx_Byte     = 0;
  reg           r_Rx_DV       = 0;
  reg [2:0]     r_SM_Main     = 0;
   
  // Purpose: Double-register the incoming data.
  // This allows it to be used in the UART RX Clock Domain.
  // (It removes problems caused by metastability)
  always @(posedge i_Clock)
    begin
      r_Rx_Data_R <= i_Rx_Serial;
      r_Rx_Data   <= r_Rx_Data_R;
    end
   
   
  // Purpose: Control RX state machine
  always @(posedge i_Clock)
    begin
       
      case (r_SM_Main)
        s_IDLE :
          begin
            r_Rx_DV       <= 1'b0;
            r_Clock_Count <= 0;
            r_Bit_Index   <= 0;
             
            if (r_Rx_Data == 1'b0)          // Start bit detected
              r_SM_Main <= s_RX_START_BIT;
            else
              r_SM_Main <= s_IDLE;
          end
         
        // Check middle of start bit to make sure it's still low
        s_RX_START_BIT :
          begin
            if (r_Clock_Count == (CLKS_PER_BIT-1)/2)
              begin
                if (r_Rx_Data == 1'b0)
                  begin
                    r_Clock_Count <= 0;  // reset counter, found the middle
                    r_SM_Main     <= s_RX_DATA_BITS;
                  end
                else
                  r_SM_Main <= s_IDLE;
              end
            else
              begin
                r_Clock_Count <= r_Clock_Count + 1;
                r_SM_Main     <= s_RX_START_BIT;
              end
          end // case: s_RX_START_BIT
         
         
        // Wait CLKS_PER_BIT-1 clock cycles to sample serial data
        s_RX_DATA_BITS :
          begin
            if (r_Clock_Count < CLKS_PER_BIT-1)
              begin
                r_Clock_Count <= r_Clock_Count + 1;
                r_SM_Main     <= s_RX_DATA_BITS;
              end
            else
              begin
                r_Clock_Count          <= 0;
                r_Rx_Byte[r_Bit_Index] <= r_Rx_Data;
                 
                // Check if we have received all bits
                if (r_Bit_Index < 7)
                  begin
                    r_Bit_Index <= r_Bit_Index + 1;
                    r_SM_Main   <= s_RX_DATA_BITS;
                  end
                else
                  begin
                    r_Bit_Index <= 0;
                    r_SM_Main   <= s_RX_STOP_BIT;
                  end
              end
          end // case: s_RX_DATA_BITS
     
     
        // Receive Stop bit.  Stop bit = 1
        s_RX_STOP_BIT :
          begin
            // Wait CLKS_PER_BIT-1 clock cycles for Stop bit to finish
            if (r_Clock_Count < CLKS_PER_BIT-1)
              begin
                r_Clock_Count <= r_Clock_Count + 1;
                r_SM_Main     <= s_RX_STOP_BIT;
              end
            else
              begin
                r_Rx_DV       <= 1'b1;
                r_Clock_Count <= 0;
                r_SM_Main     <= s_CLEANUP;
              end
          end // case: s_RX_STOP_BIT
     
        // Stay here 1 clock
        s_CLEANUP :
          begin
            r_SM_Main <= s_IDLE;
            r_Rx_DV   <= 1'b0;
          end
         
         
        default :
          r_SM_Main <= s_IDLE;
         
      endcase
    end   
   
  assign o_Rx_DV   = r_Rx_DV;
  assign o_Rx_Byte = r_Rx_Byte;
   
endmodule // uart_rx

